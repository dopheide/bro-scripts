# CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow
#
# https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html
# https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html

module DNS;

export {
    redef enum Notice::Type += {
        Possible_CVE_2015_7547_Attack,
        Possible_Weird_CVE_2015_7547_Attack
    };
}

global dns_long_len_pairs: table[addr,addr] of count &write_expire=5min &synchronized;

# A connection has to have BOTH the orig_h and resp_h in the whitelist to be ignored
# We have to do this because Bro isn't setting qtype_name=IXFR before the conn_weird event 
export {
	global cve_2015_7547_whitelist: set[addr] = [] &redef;
	type DNS_Weird: record {
		label_too_long: bool;
		truncated_RR: bool;
		conn_count: bool;
	};
	global dns_weird_conns: table[string] of DNS_Weird &write_expire=5min &synchronized;
}

function add_weird_dns_c(uid: string){
	if(uid !in dns_weird_conns){
		dns_weird_conns[uid] = [$label_too_long=F,$truncated_RR=F,$conn_count=F];
	}
}

event conn_weird(name: string, c: connection, addl: string){
    if(c$id$orig_h !in cve_2015_7547_whitelist || c$id$resp_h !in cve_2015_7547_whitelist){
        	if(name == "DNS_label_too_long"){
        		add_weird_dns_c(c$uid);
        		dns_weird_conns[c$uid]$label_too_long = T;
        	}
        	if(name == "DNS_truncated_RR_rdlength_lt_len"){
        		add_weird_dns_c(c$uid);
        		dns_weird_conns[c$uid]$truncated_RR = T;
        	}
        	if(name == "DNS_Conn_count_too_large"){
        		add_weird_dns_c(c$uid);
        		dns_weird_conns[c$uid]$conn_count = T;
        	}
        	if(dns_weird_conns[c$uid]$label_too_long == T && 
        	   dns_weird_conns[c$uid]$truncated_RR == T &&
        	   dns_weird_conns[c$uid]$conn_count == T){
        	   	if(c?$dns){
        	   		# this is for testing to see if we ever see the qtype_name
        	   		if(c$dns?$qtype_name){
						NOTICE([$note=DNS::Possible_Weird_CVE_2015_7547_Attack,
							    $conn=c,
                                $msg=fmt("Detected via Weird notices. %s",c$dns$qtype_name),
                                $src=c$id$orig_h,
                                $identifier=cat(c$id$orig_h,c$id$resp_h)
                                ]);		
        	   		}
        	   	}else{
					NOTICE([$note=DNS::Possible_Weird_CVE_2015_7547_Attack,
							    $conn=c,
                                $msg=fmt("Detected via Weird notices."),
                                $src=c$id$orig_h,
                                $identifier=cat(c$id$orig_h,c$id$resp_h)
                                ]);
    			}
        	}
    }
}

event dns_message(c: connection, is_orig: bool, msg: dns_msg, len: count){

	# so I think we need one length from an ip pair, and then a followup with a larger length
	if(c?$dns && c$dns?$qtype_name){
		if(c$dns$qtype_name == "A" || c$dns$qtype_name == "AAAA"){
			if(len > 2048){
				if(msg$TC == T){
					dns_long_len_pairs[c$id$orig_h,c$id$resp_h] = len;
				}else if((msg$TC == F) && ([c$id$orig_h,c$id$resp_h] in dns_long_len_pairs)){
					if(len > dns_long_len_pairs[c$id$orig_h,c$id$resp_h]){
						print fmt("%s",c$dns$qtype_name);
						NOTICE([$note=DNS::Possible_CVE_2015_7547_Attack,
							    $conn=c,
                                $msg=fmt("Large truncated query followed by larger query"),
                                $src=c$id$orig_h,
                                $identifier=cat(c$id$orig_h,c$id$resp_h)
                                ]);
					}
				}
			}
		}
	}
}
























