# CVE-2015-7547: glibc getaddrinfo stack-based buffer overflow
#
# https://googleonlinesecurity.blogspot.com/2016/02/cve-2015-7547-glibc-getaddrinfo-stack.html
# https://sourceware.org/ml/libc-alpha/2016-02/msg00416.html

module DNS;

export {
    redef enum Notice::Type += {
        ## Indicates that a host performed a possible Quantum Insert
        Possible_CVE_2015_7547_Attack
    };
}

global dns_long_len_pairs: table[addr,addr] of count &write_expire=5min &synchronized;

event dns_message(c: connection, is_orig: bool, msg: dns_msg, len: count){

	# so I think we need one length from an ip pair, and then a followup with a larger length
	if(c?$dns && c$dns?$qtype_name){
		if(c$dns$qtype_name == "A" || c$dns$qtype_name == "AAAA"){
			if(len > 2048){
				if(msg$TC == T){
					dns_long_len_pairs[c$id$orig_h,c$id$resp_h] = len;
				}else if((msg$TC == F) && ([c$id$orig_h,c$id$resp_h] in dns_long_len_pairs)){
					if(len > dns_long_len_pairs[c$id$orig_h,c$id$resp_h]){
						print fmt("%s",c$dns$qtype_name);
						NOTICE([$note=DNS::Possible_CVE_2015_7547_Attack,
							    $conn=c,
                                $msg=fmt("Large truncated query followed by larger query"),
                                $src=c$id$orig_h,
                                $identifier=cat(c$id$orig_h,c$id$resp_h)
                                ]);
					}
				}
			}
		}
	}
}
























